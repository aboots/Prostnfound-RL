import logging
import math
import warnings

import matplotlib.pyplot as plt
import numpy as np
import torch
import wandb
import skimage


def _no_grad_trunc_normal_(tensor, mean, std, a, b):
    # Cut & paste from PyTorch official master until it's in a few official releases - RW
    # Method based on https://people.sc.fsu.edu/~jburkardt/presentations/truncated_normal.pdf
    def norm_cdf(x):
        # Computes standard normal cumulative distribution function
        return (1.0 + math.erf(x / math.sqrt(2.0))) / 2.0

    if (mean < a - 2 * std) or (mean > b + 2 * std):
        warnings.warn(
            "mean is more than 2 std from [a, b] in nn.init.trunc_normal_. "
            "The distribution of values may be incorrect.",
            stacklevel=2,
        )

    with torch.no_grad():
        # Values are generated by using a truncated uniform distribution and
        # then using the inverse CDF for the normal distribution.
        # Get upper and lower cdf values
        l = norm_cdf((a - mean) / std)
        u = norm_cdf((b - mean) / std)

        # Uniformly fill tensor with values from [l, u], then translate to
        # [2l-1, 2u-1].
        tensor.uniform_(2 * l - 1, 2 * u - 1)

        # Use inverse cdf transform for normal distribution to get truncated
        # standard normal
        tensor.erfinv_()

        # Transform to proper mean, std
        tensor.mul_(std * math.sqrt(2.0))
        tensor.add_(mean)

        # Clamp to ensure it's in the proper range
        tensor.clamp_(min=a, max=b)
        return tensor


def trunc_normal_(tensor, mean=0.0, std=1.0, a=-2.0, b=2.0):
    # type: (Tensor, float, float, float, float) -> Tensor
    return _no_grad_trunc_normal_(tensor, mean, std, a, b)


def calculate_metrics(predictions, labels, log_images=False):
    """Calculate metrics for the cancer classification problem."""

    if isinstance(predictions, torch.Tensor):
        predictions = predictions.cpu().numpy()
    if isinstance(labels, torch.Tensor):
        labels = labels.cpu().numpy()

    # augmentations can cause NaNs
    nanvalues = np.isnan(predictions)
    predictions = predictions[~nanvalues]
    labels = labels[~nanvalues]

    if len(predictions) == 0:
        logging.warning("All predictions were NaN or empty. Returning NaN metrics.")
        return {
            "core_auc": float("nan"),
            "sensitivity": float("nan"),
            "specificity": float("nan"),
            "f1": float("nan"),
        }

    from sklearn.metrics import (
        balanced_accuracy_score,
        f1_score,
        recall_score,
        roc_auc_score,
        roc_curve,
    )

    metrics = {}

    # core predictions
    core_probs = predictions
    core_labels = labels
    
    # Check that we have both classes (required for AUC and other metrics)
    unique_labels = np.unique(core_labels)
    if len(unique_labels) < 2:
        logging.warning(f"Only one class present in labels: {unique_labels}. Returning NaN metrics.")
        return {
            "core_auc": float("nan"),
            "sensitivity": float("nan"),
            "specificity": float("nan"),
            "f1": float("nan"),
        }
    
    metrics["core_auc"] = roc_auc_score(core_labels, core_probs)

    # find the sensitivity at fixed specificities
    fpr, tpr, thresholds = roc_curve(core_labels, core_probs)

    for specificity in [0.20, 0.40, 0.60, 0.80]:
        sensitivity = tpr[np.argmax(fpr > 1 - specificity)]
        metrics[f"sens_at_{specificity*100:.0f}_spe"] = sensitivity

    metrics['sensitivity'] = recall_score(core_labels, core_probs > 0.5)
    metrics['specificity'] = recall_score(core_labels, core_probs > 0.5, pos_label=0)

    # choose the threshold that maximizes balanced accuracy
    best_threshold = thresholds[np.argmax(tpr - fpr)]
    metrics["f1"] = f1_score(core_labels, core_probs > best_threshold)

    if log_images:
        try:
            plt.figure()
            # Use fewer bins if data range is small (e.g., in debug mode)
            n_bins = min(100, max(10, len(core_probs) // 10))
            plt.hist(core_probs[core_labels == 0], bins=n_bins, alpha=0.5, density=True)
            plt.hist(core_probs[core_labels == 1], bins=n_bins, alpha=0.5, density=True)
            plt.legend(["Benign", "Cancer"])
            plt.xlabel(f"Probability of cancer")
            plt.ylabel("Density")
            plt.title(f"Core AUC: {metrics['core_auc']:.3f}")
            metrics["histogram"] = wandb.Image(plt, caption="Histogram of core predictions")
            plt.close()
        except (ValueError, RuntimeError) as e:
            # Handle cases with too little data (e.g., debug mode)
            logging.warning(f"Could not create histogram: {e}")
            plt.close()

        plt.figure()
        plt.plot(fpr, tpr)
        plt.xlabel("False positive rate")
        plt.ylabel("True positive rate")
        plt.title("ROC curve")
        metrics["roc_curve"] = wandb.Image(plt, caption="ROC curve")
        plt.close()

    return metrics


def render_heatmap(
    ax,
    raw_image,
    heatmap,
    prostate_mask=None, 
    needle_mask=None, 
    height_mm=28,
    width_mm=46.06,
    start_alpha=0,
    stop_alpha=0.7,
    alpha_cutoff=0.1,
    apply_prostate_mask=False, 
    style='miccai',
    dataset=None, 
    show_title=False,
    model_score=None, 
    pri_mus=None, 
    pi_rads=None,
    core_id=None,
    label=None,
    grade_group=None, 
    pct_cancer=None, 

):

    from matplotlib import pyplot as plt
    import matplotlib.colors as mcolors

    def cancer_prob_colormap(alpha_cutoff=0.1, start_alpha=0., stop_alpha=1.):
        """
        Returns a colormap that fades in from transparent to jet-like colors.
        Values below `alpha_cutoff` will be fully transparent.
        """
        base = plt.cm.jet(np.linspace(0, 1, 256))

        # Create alpha channel: transparent below cutoff, then ramp to 1
        alpha = np.linspace(start_alpha, stop_alpha, 256)
        alpha[: int(256 * alpha_cutoff)] = 0  # Fully transparent low values
        base[:, -1] = alpha  # Set alpha channel

        return mcolors.ListedColormap(base, name="cancer_prob_jet_alpha")

    cancer_cmap = cancer_prob_colormap(
        alpha_cutoff=alpha_cutoff, start_alpha=start_alpha, stop_alpha=stop_alpha
    )

    # basic heatmap for display
    extent = [0, width_mm, 0, height_mm]
    extent_flipped = [0, width_mm, height_mm, 0]

    # fig, ax = plt.subplots(1, 2, figsize=(8, 3))

    ax[0].imshow(raw_image, cmap="gray", extent=extent)
    if style == "miccai" and prostate_mask is not None:
        ax[0].contour(prostate_mask, extent=extent_flipped, colors="white", alpha=0.5)
    ax[0].set_axis_off()

    ax[1].imshow(raw_image, cmap="gray", extent=extent)

    if apply_prostate_mask and prostate_mask is not None and needle_mask is not None:
        alpha = np.ones(heatmap.shape, dtype="float") * stop_alpha
        prostate_mask_resized = skimage.transform.resize(
            prostate_mask, heatmap.shape, preserve_range=True, order=0
        ).astype(bool)
        needle_mask_resized = skimage.transform.resize(
            needle_mask, heatmap.shape, preserve_range=True, order=0
        ).astype(bool)
        alpha[prostate_mask_resized & ~needle_mask_resized] = 0.4
        alpha[~prostate_mask_resized] = 0
    else:
        alpha = None

    if needle_mask is not None:
        ax[1].contour(needle_mask, extent=extent_flipped, colors="white", alpha=0.5)
    if apply_prostate_mask:
        ax[1].contour(prostate_mask, extent=extent_flipped, colors="black", alpha=0.5)
    artist = ax[1].imshow(
        heatmap, extent=extent, vmin=0, vmax=1, cmap=cancer_cmap, alpha=alpha
    )
    # ax[1].set_title("Heatmap overlay")
    ax[1].set_axis_off()
    # plt.contour(prostate_mask, extent=extent_flipped)

    if show_title: 
 
        if label == 0:
            title = f"{core_id} | Benign"
        else:
            title = f"{core_id} - {pct_cancer} % cancer - Grade Group {grade_group}"
        ax[0].set_title(title)

        title = ""
        if dataset == "optimum":
            try:
                title += f"PRI-MUS {int(pri_mus)}"
            except:
                pass
            if not np.isnan(pi_rads) and pi_rads is not None:
                try:
                    title += f" | PI-RADS {int(pi_rads)}"
                except:
                    pass
            if model_score is not None:
                title += f" | Model {model_score}"
        ax[1].set_title(title)
